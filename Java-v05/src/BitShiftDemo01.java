/**
 * 位移运算符
 */
public class BitShiftDemo01 {
    public static void main(String[] args) {
        // 左移：value<<num
        // 将value的2进制形式向左移动num位，每次移动，高阶位会被移出并丢弃，右侧用0填充
        // 每一次左移相当于原始值乘以2，是乘以2的高效替代方案，但如果把1移动到高阶位上，则结果变为负数
        int a = 30;// 00000000000000000000000000011110
        System.out.println(a<<2);// 00000000000000000000000001111000=120
        System.out.println("------------------------------");

        // 因为以下语句执行左移后，高阶位被团置为1，所以是负数
        System.out.println(268435454<<1);// 00011111111111111111111111111100=>-536870908
        System.out.println(268435454<<2);// 00111111111111111111111111111000=>-1073741816
        System.out.println(268435454<<3);// 01111111111111111111111111110000=>-2147483632
        System.out.println(268435454<<4);// 11111111111111111111111111100000=>-32
        System.out.println("------------------------------");

        // byte和short在左移时会产生意外结果，因为这两种类型在运算时会被自动提升为int
        byte b = 64;// 01000000
        int c = b<<2;// b自动提升为int：00000000000000000000000001000000，左移2位：00000000000000000000000100000000=>256
        System.out.println(c);// 256，已经超出了byte的范围
        // 可以使用强制类型转换来解决这类问题
        byte d = (byte)(b<<2);
        System.out.println(d);// 0，移位后00000000000000000000000100000000，转型后只保留低阶8位00000000，所以结果是0
        System.out.println("------------------------------");

        // 右移：value>>num
        // 将value的2进制形式向右移动num位，每次移动，低阶位会被移出并丢弃，左侧用符号位填充
        // 每一次左移相当于原始值除以2，是乘以2的高效替代方案，但如果把1移动到高阶位上，则结果变为负数
        System.out.println(8>>2);// 2
        System.out.println(-8>>2);// -2
        System.out.println("------------------------------");

        // 无符号右移：value>>>num
        // 将value的2进制形式向右移动num位，每次移动，低阶位会被移出并丢弃，左侧用0填充
        // 不常用
        int e = -1;// 11111111111111111111111111111111
        e = e>>>24;// 00000000000000000000000011111111
        System.out.println(e);// 255

    }
}
